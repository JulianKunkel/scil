#include <scil-quantizer.h>

#include <math.h>

<DATATYPE> scil_find_minimum_<DATATYPE>(const <DATATYPE>* const buffer,
                                        const size_t count){
    <DATATYPE> min = INFINITY;

    for(size_t i = 0; i < count; ++i)
    {
        if(buffer[i] < min) { min = buffer[i]; }
    }

    return min;
}

<DATATYPE> scil_find_maximum_<DATATYPE>(const <DATATYPE>* const buffer,
                                        const size_t count){
    <DATATYPE> max = -INFINITY;

    for(size_t i = 0; i < count; ++i)
    {
        if(buffer[i] > max) { max = buffer[i]; }
    }

    return max;
}

void scil_find_minimum_maximum_<DATATYPE>(const <DATATYPE>* const restrict buffer,
                                          const size_t count,
                                          <DATATYPE>* const minimum,
                                          <DATATYPE>* const maximum){
    <DATATYPE> min = INFINITY;
    <DATATYPE> max = -INFINITY;

    for(size_t i = 0; i < count; ++i){
        if (buffer[i] < min) { min = buffer[i]; }
        if (buffer[i] > max) { max = buffer[i]; }
    }

    *minimum = min;
    *maximum = max;
}

uint64_t scil_calculate_bits_needed_<DATATYPE>(const <DATATYPE> minimum,
                                               const <DATATYPE> maximum,
                                               const double absolute_tolerance){
    return (uint64_t)ceil( log2( 1 + (maximum - minimum) / (2 * absolute_tolerance) ) );
}

static uint64_t scil_quantize_value_<DATATYPE>(const <DATATYPE> value,
                                               const double absolute_tolerance,
                                               const <DATATYPE> minimum){
    return (uint64_t)round( (value - minimum) / (2 * absolute_tolerance) );
}

static <DATATYPE> scil_unquantize_value_<DATATYPE>(const uint64_t value,
                                                   const double absolute_tolerance,
                                                   const <DATATYPE> minimum){
    return minimum + (<DATATYPE>)(value * 2 * absolute_tolerance);
}

int scil_quantize_buffer_minmax_<DATATYPE>(uint64_t* const restrict buf_out,
                                           const <DATATYPE>* const restrict buf_in,
                                           const size_t count,
                                           const double absolute_tolerance,
                                           const <DATATYPE> minimum,
                                           const <DATATYPE> maximum){
    if(scil_calculate_bits_needed_<DATATYPE>(minimum, maximum, absolute_tolerance) > 64){
        return 1; // Quantizing would result in values bigger than UINT64_MAX
    }

    for(size_t i = 0; i < count; ++i){
        buf_out[i] = scil_quantize_value_<DATATYPE>(buf_in[i], minimum, absolute_tolerance);
    }

    return 0;
}

int scil_unquantize_buffer_<DATATYPE>(<DATATYPE>* const restrict buf_out,
                                      const uint64_t* const restrict buf_in,
                                      const size_t count,
                                      const double absolute_tolerance,
                                      const <DATATYPE> minimum){
    for(size_t i = 0; i < count; ++i){
        buf_out[i] = scil_unquantize_value_<DATATYPE>(buf_in[i], minimum, absolute_tolerance);
    }

    return 0;
}

int scil_quantize_buffer_<DATATYPE>(uint64_t* const restrict buf_out,
                                    const <DATATYPE>* const restrict buf_in,
                                    const size_t count,
                                    const double absolute_tolerance){
    <DATATYPE> minimum, maximum;
    scil_find_minimum_maximum_<DATATYPE>(buf_in, count, &minimum, &maximum);

    return scil_quantize_buffer_minmax_<DATATYPE>(buf_out, buf_in, count, absolute_tolerance, minimum, maximum);
}
