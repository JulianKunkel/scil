// This file is part of SCIL.
//
// SCIL is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SCIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with SCIL.  If not, see <http://www.gnu.org/licenses/>.

#include <scil.h>
#include <scil-swager.h>

#include <algo/algo-sigbits.h>
#include <algo/algo-sigbits-init.c.x>

static void find_minimums_and_maximums_<DATATYPE>(const <DATATYPE>* const buffer,
                                                  const size_t size,
                                                  uint8_t* const minimum_sign,
                                                  uint8_t* const maximum_sign,
                                                  int16_t* const minimum_exponent,
                                                  int16_t* const maximum_exponent){

    *minimum_sign = 1;
    *maximum_sign = 0;

    *minimum_exponent = 0x7fff;
    *maximum_exponent = -*minimum_exponent;

    for(size_t i = 0; i < size; ++i){

        datatype_cast_<DATATYPE> cur;
        cur.f = buffer[i];

        if(*minimum_sign != 0 && cur.p.sign < *minimum_sign) *minimum_sign = cur.p.sign;
        if(*maximum_sign != 1 && cur.p.sign > *maximum_sign) *maximum_sign = cur.p.sign;

        if(cur.p.exponent < *minimum_exponent) *minimum_exponent = cur.p.exponent;
        if(cur.p.exponent > *maximum_exponent) *maximum_exponent = cur.p.exponent;
    }
}

static void get_header_data_<DATATYPE>(const <DATATYPE>* const source,
                                       size_t count,
                                       uint8_t* const signs_id,
                                       uint8_t* const exponent_bit_count,
                                       int16_t* const minimum_exponent){

    uint8_t minimum_sign, maximum_sign;
    int16_t maximum_exponent;
    find_minimums_and_maximums_<DATATYPE>(source,
                                          count,
                                          &minimum_sign,
                                          &maximum_sign,
                                          minimum_exponent,
                                          &maximum_exponent);

    *signs_id = calc_sign_bit_count(minimum_sign, maximum_sign);
    *exponent_bit_count = calc_exponent_bit_count(*minimum_exponent, maximum_exponent);
}

static uint64_t compress_value_<DATATYPE>(<DATATYPE> value,
                                          uint8_t signs_id,
                                          uint8_t exponent_bit_count,
                                          uint8_t mantissa_bit_count,
                                          int16_t minimum_exponent){

    uint64_t result = 0;

    datatype_cast_<DATATYPE> cur;
    cur.f = value;

    if(signs_id == 2){
        result = ((uint64_t)cur.p.sign) << exponent_bit_count;
    }
    result |= (uint64_t)(cur.p.exponent - minimum_exponent);
    result <<= mantissa_bit_count;
    result |= ((uint64_t)cur.p.mantissa) >> (MANTISSA_LENGTH_<DATATYPE_UPPER> - mantissa_bit_count);

    return result;
}

static <DATATYPE> decompress_value_<DATATYPE>(uint64_t value,
                                              uint8_t bit_count_per_value,
                                              uint8_t signs_id,
                                              uint8_t exponent_bit_count,
                                              uint8_t mantissa_bit_count,
                                              int16_t minimum_exponent){

    datatype_cast_<DATATYPE> cur;

    cur.p.sign = get_sign(value, bit_count_per_value, signs_id);
    cur.p.exponent = get_exponent(value, exponent_bit_count, mantissa_bit_count, minimum_exponent);
    cur.p.mantissa = get_mantissa_<DATATYPE>(value, mantissa_bit_count);

    return cur.f;
}

static int compress_buffer_<DATATYPE>(uint64_t* const restrict dest,
                                      const <DATATYPE>* const restrict source,
                                      size_t count,
                                      uint8_t signs_id,
                                      uint8_t exponent_bit_count,
                                      uint8_t mantissa_bit_count,
                                      uint8_t minimum_exponent){

    for(size_t i = 0; i < count; ++i){
        dest[i] = compress_value_<DATATYPE>(source[i], signs_id, exponent_bit_count, mantissa_bit_count, minimum_exponent);
    }

    return SCIL_NO_ERR;
}

static int decompress_buffer_<DATATYPE>(<DATATYPE>* const restrict dest,
                                        const uint64_t* restrict source,
                                        size_t count,
                                        uint8_t bit_count_per_value,
                                        uint8_t signs_id,
                                        uint8_t exponent_bit_count,
                                        uint8_t mantissa_bit_count,
                                        uint8_t minimum_exponent){

    for (size_t i = 0; i < count; ++i) {
        dest[i] = decompress_value_<DATATYPE>(source[i], bit_count_per_value, signs_id, exponent_bit_count, mantissa_bit_count, minimum_exponent);
    }

    return SCIL_NO_ERR;
}

int scil_sigbits_compress_<DATATYPE>(const scil_context_p ctx,
                                     byte * restrict dest,
                                     size_t* dest_size,
                                     <DATATYPE>*restrict source,
                                     const scil_dims* dims){

    assert(ctx != NULL);
    assert(dest != NULL);
    assert(dest_size != NULL);
    assert(source != NULL);
    assert(dims != NULL);

    // ==================== Initialization =====================================

    size_t count = scil_get_data_count(dims);

    uint8_t mantissa_bit_count = ctx->hints.significant_bits;

    uint8_t signs_id, exponent_bit_count;
    int16_t minimum_exponent;
    get_header_data_<DATATYPE>(source, count, &signs_id, &exponent_bit_count, &minimum_exponent);

    uint8_t bit_count_per_value = get_bit_count_per_value(signs_id, exponent_bit_count, mantissa_bit_count);
    if(bit_count_per_value >= 8 * sizeof(<DATATYPE>)){
        return SCIL_PRECISION_ERR;
    }

    write_header(dest, signs_id, exponent_bit_count, mantissa_bit_count, minimum_exponent);

    *dest_size = round_up_byte(bit_count_per_value * count) + SCIL_SIGBITS_HEADER_SIZE;

    int ret = SCIL_NO_ERR;

    // ==================== Compression ========================================

    // Allocate intermediate buffer
    uint64_t* compressed_buffer = (uint64_t*)SAFE_MALLOC(count * sizeof(uint64_t));

    // Compress each value in source buffer
    if(compress_buffer_<DATATYPE>(compressed_buffer, source, count, signs_id, exponent_bit_count, mantissa_bit_count, minimum_exponent)){
        ret = SCIL_BUFFER_ERR;
        goto comp_cleanup;
    }

    // Pack compressed values tightly
    if(scil_swage(dest, compressed_buffer, count, (uint8_t)bit_count_per_value)){
        ret = SCIL_BUFFER_ERR;
        goto comp_cleanup;
    }

    // ==================== Cleanup ============================================

    comp_cleanup:
    free(compressed_buffer);
    return ret;
}

int scil_sigbits_decompress_<DATATYPE>(<DATATYPE>*restrict dest,
                                       scil_dims* dims,
                                       byte*restrict source,
                                       size_t source_size){

    assert(dest != NULL);
    assert(dims != NULL);
    assert(source != NULL);

    // ==================== Initialization =====================================

    size_t count = scil_get_data_count(dims);

    size_t source_size_cp = source_size;

    uint8_t signs_id, exponent_bit_count, mantissa_bit_count;
    int16_t minimum_exponent;
    read_header(source,
                &source_size_cp,
                &signs_id,
                &exponent_bit_count,
                &mantissa_bit_count,
                &minimum_exponent);

    uint8_t bit_count_per_value = get_bit_count_per_value(signs_id, exponent_bit_count, mantissa_bit_count);

    // ==================== Decompression ======================================

    uint64_t* unswaged_buffer = (uint64_t*)SAFE_MALLOC(count * sizeof(uint64_t));

    int ret = SCIL_NO_ERR;

    if(scil_unswage(unswaged_buffer, source, count, bit_count_per_value)){
        ret = SCIL_BUFFER_ERR;
        goto decomp_cleanup;
    }

    if(decompress_buffer_<DATATYPE>(dest,
                                    unswaged_buffer,
                                    count,
                                    bit_count_per_value,
                                    signs_id,
                                    exponent_bit_count,
                                    mantissa_bit_count,
                                    minimum_exponent) ){
        ret = SCIL_BUFFER_ERR;
        goto decomp_cleanup;
    }

    // ==================== Cleanup ============================================

    decomp_cleanup:
    free(unswaged_buffer);
    return ret;
}
