// This file is part of SCIL.
//
// SCIL is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SCIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with SCIL.  If not, see <http://www.gnu.org/licenses/>.

/*
 * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include <math.h>
#include <string.h>

#include <algo/algo-opj.h>

#include <openjpeg.h>
#include <opj_config.h>

/* -------------------------------------------------------------------------- */
//Supported datatypes: float double int8 int16 int32 int64

#define NUM_COMPS_MAX 4
// Repeat for each data type

#pragma GCC diagnostic ignored "-Wunused-parameter"
int scil_opj_compress_<DATATYPE>(const scil_context_p ctx, byte* restrict dest, size_t* restrict dest_size, <DATATYPE>* restrict source, const scil_dims* dims)
{
  opj_cparameters_t l_param;
  opj_codec_t * l_codec;
  opj_image_t * l_image;
  opj_image_cmptparm_t l_params [NUM_COMPS_MAX];
  opj_stream_t * l_stream;
  OPJ_UINT32 l_nb_tiles;
  OPJ_UINT32 l_data_size;
  // unsigned char len;

  opj_image_cmptparm_t * l_current_param_ptr;
  OPJ_UINT32 i;//,j,k;

  OPJ_UINT32 num_comps;
  int image_width;
  int image_height;
  int tile_width;
  int tile_height;
  int comp_prec;
  int irreversible;
  char output_file[64];

  if(dims->dims == 2)
  {
    /*if (dims->length[0] < 64 || dims->length[1] < 64)
    {
      fprintf(stderr, "ERROR -> test_tile_encoder: size of each dimention must be equal or over 64!\n");
      return 1;
    }
    else*/
    {
      image_height = tile_height = dims->length[1];
      image_width = tile_width = dims->length[0];
    }
  }
  else
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: number of dimensions not equal 2!\n");
    return 1;
  }

  num_comps = 1;
  comp_prec = 24;
  irreversible = 1;
  strcpy(output_file, "test.j2k" );

  if( num_comps > NUM_COMPS_MAX )
  {
    return 1;
  }
  l_nb_tiles = 1;
  l_data_size = (OPJ_UINT32)tile_width * (OPJ_UINT32)tile_height * (OPJ_UINT32)num_comps * (OPJ_UINT32)(comp_prec/24) * sizeof(OPJ_FLOAT32);


  opj_set_default_encoder_parameters(&l_param);
  /** you may here add custom encoding parameters */
  /* rate specifications */
  /** number of quality layers in the stream */
  l_param.tcp_numlayers = 1;
  l_param.cp_fixed_quality = 1;
  l_param.tcp_distoratio[0] = 20;
  /* is using others way of calculation */
  /* l_param.cp_disto_alloc = 1 or l_param.cp_fixed_alloc = 1 */
  /* l_param.tcp_rates[0] = ... */


  /* tile definitions parameters */
  /* position of the tile grid aligned with the image */
  l_param.cp_tx0 = 0;
  l_param.cp_ty0 = 0;
  /* tile size, we are using tile based encoding */
  l_param.tile_size_on = OPJ_TRUE;
  l_param.cp_tdx = tile_width;
  l_param.cp_tdy = tile_height;

  /* use irreversible encoding ?*/
  l_param.irreversible = irreversible;

  /* do not bother with mct, the rsiz is set when calling opj_set_MCT*/
  /*l_param.cp_rsiz = OPJ_STD_RSIZ;*/

  /* no cinema */
  /*l_param.cp_cinema = 0;*/

  /* no not bother using SOP or EPH markers, do not use custom size precinct */
  /* number of precincts to specify */
  /* l_param.csty = 0;*/
  /* l_param.res_spec = ... */
  /* l_param.prch_init[i] = .. */
  /* l_param.prcw_init[i] = .. */


  /* do not use progression order changes */
  /*l_param.numpocs = 0;*/
  /* l_param.POC[i].... */

  /* do not restrain the size for a component.*/
  /* l_param.max_comp_size = 0; */

  /** block encoding style for each component, do not use at the moment */
  /** J2K_CCP_CBLKSTY_TERMALL, J2K_CCP_CBLKSTY_LAZY, J2K_CCP_CBLKSTY_VSC, J2K_CCP_CBLKSTY_SEGSYM, J2K_CCP_CBLKSTY_RESET */
  /* l_param.mode = 0;*/

  /** number of resolutions */
  l_param.numresolution = 6;

  /** progression order to use*/
  /** OPJ_LRCP, OPJ_RLCP, OPJ_RPCL, PCRL, CPRL */
  l_param.prog_order = OPJ_LRCP;

  /** no "region" of interest, more precisally component */
  /* l_param.roi_compno = -1; */
  /* l_param.roi_shift = 0; */

  /* we are not using multiple tile parts for a tile. */
  /* l_param.tp_on = 0; */
  /* l_param.tp_flag = 0; */


  /* image definition */
  l_current_param_ptr = l_params;
  for (i=0;i<num_comps;++i) {
    /* do not bother bpp useless */
    /*l_current_param_ptr->bpp = COMP_PREC;*/
    l_current_param_ptr->dx = 1;
    l_current_param_ptr->dy = 1;

    l_current_param_ptr->h = (OPJ_UINT32)image_height;
    l_current_param_ptr->w = (OPJ_UINT32)image_width;

    l_current_param_ptr->sgnd = 0;
    l_current_param_ptr->prec = (OPJ_UINT32)comp_prec;

    l_current_param_ptr->x0 = 0;
    l_current_param_ptr->y0 = 0;

    ++l_current_param_ptr;
  }

  l_codec = opj_create_compress(OPJ_CODEC_J2K);

  if (!l_codec) {
    return 1;
  }

  l_image = opj_image_tile_create(num_comps,l_params,OPJ_CLRSPC_GRAY);
  if (! l_image) {
    opj_destroy_codec(l_codec);
    return 1;
  }

  l_image->x0 = 0;
  l_image->y0 = 0;
  l_image->x1 = (OPJ_UINT32)image_width;
  l_image->y1 = (OPJ_UINT32)image_height;
  l_image->color_space = OPJ_CLRSPC_GRAY;

  if (! opj_setup_encoder(l_codec,&l_param,l_image)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to setup the codec!\n");
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

    l_stream = opj_stream_create_default_file_stream(output_file, OPJ_FALSE);
    if (! l_stream) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to create the stream from the output file %s !\n",output_file );
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_start_compress(l_codec,l_image,l_stream)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to start compress!\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  for (i=0;i<l_nb_tiles;++i) {
    if (! opj_write_tile(l_codec,i,(byte*) source,l_data_size,l_stream)) {
      fprintf(stderr, "ERROR -> test_tile_encoder: failed to write the tile %d!\n",i);
      opj_stream_destroy(l_stream);
      opj_destroy_codec(l_codec);
      opj_image_destroy(l_image);
      return 1;
    }
  }

  if (! opj_end_compress(l_codec,l_stream)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to end compress!\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  opj_stream_destroy(l_stream);
  opj_destroy_codec(l_codec);
  opj_image_destroy(l_image);

  /*READ RESULTS FROM FILE*/

  FILE *fp;

  if ((fp = fopen(output_file, "rb")) == NULL)
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error opening file\n");
    return 1;
  }

  fseek(fp,0,SEEK_END);
  int size = ftell(fp);
  fseek(fp,0,SEEK_SET);
  fread(dest, sizeof(OPJ_BYTE), size, fp);
  fclose(fp);

  if( remove( output_file ) != 0 )
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error deleting file\n");
    return 1;
  }

  *dest_size = size;


  return SCIL_NO_ERR;
}

#pragma GCC diagnostic ignored "-Wunused-parameter"
int scil_opj_decompress_<DATATYPE>(<DATATYPE>* restrict dest, scil_dims* dims, byte* restrict source, const size_t _size)
{
  opj_dparameters_t l_param;
  opj_codec_t * l_codec;
  opj_image_t * l_image;
  opj_stream_t * l_stream;
  OPJ_UINT32 l_data_size;
  OPJ_UINT32 l_max_data_size = _size;
  OPJ_UINT32 l_tile_index;
  OPJ_BYTE * l_data = (OPJ_BYTE *) malloc(dims->length[0] * dims->length[1] * sizeof(float));
  OPJ_BOOL l_go_on = OPJ_TRUE;
  OPJ_UINT32 l_nb_comps=0 ;
  OPJ_INT32 l_current_tile_x0,l_current_tile_y0,l_current_tile_x1,l_current_tile_y1;

  int da_x0=0;
  int da_y0=0;
  int da_x1=(OPJ_UINT32)dims->length[0] * sizeof(float);
  int da_y1=(OPJ_UINT32)dims->length[1];
  char input_file[64];

  strcpy(input_file,"test.j2k");

  if (! l_data) {
    return 1;
  }

  printf("ENCODED: %i %i %i %i \n",source[0], source[1],source[2],source[3]);

  /*WRITE FILE*/

  FILE *fp;

  if ((fp = fopen(input_file, "wb")) == NULL)
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error opening file\n");
    return 1;
  }

  fwrite (source, sizeof(float) * dims->length[0] * dims->length[1], 1, fp);
  fclose (fp);


  /*WRITE FILE*/

  l_stream = opj_stream_create_default_file_stream(input_file,OPJ_TRUE);
  if (!l_stream){
    free(l_data);
    fprintf(stderr, "ERROR -> failed to create the stream from the file\n");
    return 1;
  }

  /* Set the default decoding parameters */
  opj_set_default_decoder_parameters(&l_param);

  /* */
  l_param.decod_format = OPJ_CODEC_J2K;

  /** you may here add custom decoding parameters */
  /* do not use layer decoding limitations */
  l_param.cp_layer = 0;

  /* do not use resolutions reductions */
  l_param.cp_reduce = 0;

  /* to decode only a part of the image data */
  /*opj_restrict_decoding(&l_param,0,0,1000,1000);*/


  /* JPEG-2000 codestream */

  /* Get a decoder handle */
  l_codec = opj_create_decompress(OPJ_CODEC_J2K);

  /* Setup the decoder decoding parameters using user parameters */
  if (! opj_setup_decoder(l_codec, &l_param))
  {
    fprintf(stderr, "ERROR -> j2k_dump: failed to setup the decoder\n");
    free(l_data);
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    return 1;
  }

  /* Read the main header of the codestream and if necessary the JP2 boxes*/
  if (! opj_read_header(l_stream, l_codec, &l_image))
  {
    fprintf(stderr, "ERROR -> j2k_to_image: failed to read the header\n");
    free(l_data);
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    return 1;
  }

  if (!opj_set_decode_area(l_codec, l_image, da_x0, da_y0,da_x1, da_y1))
  {
    fprintf(stderr,	"ERROR -> j2k_to_image: failed to set the decoded area\n");
    free(l_data);
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  while (l_go_on)
  {
    if (! opj_read_tile_header( l_codec,
                            l_stream,
                            &l_tile_index,
                            &l_data_size,
                            &l_current_tile_x0,
                            &l_current_tile_y0,
                            &l_current_tile_x1,
                            &l_current_tile_y1,
                            &l_nb_comps,
                            &l_go_on))
    {
      free(l_data);
      opj_stream_destroy(l_stream);
      opj_destroy_codec(l_codec);
      opj_image_destroy(l_image);
      return 1;
    }

    /*printf("%i %i %i %i %i %i %i %i \n", l_tile_index,
    l_data_size,
    l_current_tile_x0,
    l_current_tile_y0,
    l_current_tile_x1,
    l_current_tile_y1,
    l_nb_comps,
    l_go_on);*/

    if (l_go_on)
    {
      if (l_data_size > l_max_data_size)
      {
        OPJ_BYTE *l_new_data = (OPJ_BYTE *) realloc(l_data, l_data_size);
        if (! l_new_data)
        {
          free(l_new_data);
          opj_stream_destroy(l_stream);
          opj_destroy_codec(l_codec);
          opj_image_destroy(l_image);
          return 1;
        }
        l_data = l_new_data;
        l_max_data_size = l_data_size;
        printf("%i ",l_data[0]);
      }

      if (! opj_decode_tile_data(l_codec,l_tile_index,l_data,l_data_size,l_stream))
      {
        free(l_data);
        opj_stream_destroy(l_stream);
        opj_destroy_codec(l_codec);
        opj_image_destroy(l_image);
        return 1;
      }
      /** now should inspect image to know the reduction factor and then how to behave with data */
    }
  }

  if (! opj_end_decompress(l_codec,l_stream))
  {
    free(l_data);
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  printf("DECODED:%i %i %i %i \n",l_data[0], l_data[1],l_data[2],l_data[3]);

  /* Free memory */
  free(l_data);
  opj_stream_destroy(l_stream);
  opj_destroy_codec(l_codec);
  opj_image_destroy(l_image);
  return 0;
}

// End repeat

scil_compression_algorithm algo_opj = {
    .c.DNtype = {
	      CREATE_INITIALIZER(scil_opj)
    },
    "opj",
    9,//compressor_id
    SCIL_COMPRESSOR_TYPE_DATATYPES,
    0 //is_lossy
};
