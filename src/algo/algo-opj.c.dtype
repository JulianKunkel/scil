// This file is part of SCIL.
//
// SCIL is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SCIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with SCIL.  If not, see <http://www.gnu.org/licenses/>.

/*
 * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include <math.h>
#include <string.h>

#include <algo/algo-opj.h>

#include <openjpeg.h>
#include <opj_config.h>

/* -------------------------------------------------------------------------- */
//Supported datatypes: float double int8 int16 int32 int64

// Repeat for each data type

#pragma GCC diagnostic ignored "-Wunused-parameter"
int scil_opj_compress_<DATATYPE>(const scil_context_p ctx, byte* restrict dest, size_t* restrict dest_size, <DATATYPE>* restrict source, const scil_dims* dims)
{
  opj_cparameters_t l_param;
  opj_codec_t * l_codec;
  opj_image_t * l_image;
  opj_image_cmptparm_t cmptparm[1];
  opj_stream_t * l_stream;

  OPJ_UINT32 i;//,j,k;

  OPJ_UINT32 num_comps;
  int image_width;
  int image_height;
  int comp_prec;
  int irreversible;
  char output_file[64];
  OPJ_BOOL quantize = 0;

  size_t input_size = scil_get_data_size(ctx->datatype, dims);

  /*if(ctx->datatype == SCIL_TYPE_FLOAT){
    quantize = 1;
    int32_t *source_quant = (int32_t)SAFE_MALLOC(input_size);
  }*/

  if(dims->dims == 2)
  {
    if (dims->length[0] < 64 || dims->length[1] < 64)
    {
      fprintf(stderr, "ERROR -> test_tile_encoder: size of each dimention must be equal or over 64!\n");
      return 1;
    }
    else
    {
      image_height = dims->length[1];
      image_width = dims->length[0];
    }
  }
  else
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: number of dimensions not equal 2!\n");
    return 1;
  }

  num_comps = 1;
  comp_prec = 8;
  irreversible = 1;
  strcpy(output_file, "test.jp2" );

  opj_set_default_encoder_parameters(&l_param);
  /** you may here add custom encoding parameters */
  /* rate specifications */
  /** number of quality layers in the stream */
  l_param.tcp_numlayers = 1;
  l_param.cp_fixed_quality = 1;
  l_param.tcp_distoratio[0] = 20;

  /* use irreversible encoding ?*/
  l_param.irreversible = irreversible;

  /** number of resolutions */
  l_param.numresolution = 6;

  l_param.prog_order = OPJ_LRCP;


  memset(&cmptparm[0], 0, sizeof(opj_image_cmptparm_t));
  for(i = 0; i < num_comps; i++)
  {
      cmptparm[i].prec = comp_prec;
      cmptparm[i].bpp = 8;
      cmptparm[i].sgnd = 0;
      cmptparm[i].dx = (OPJ_UINT32)1;
      cmptparm[i].dy = (OPJ_UINT32)1;
      cmptparm[i].w = (OPJ_UINT32)image_width;
      cmptparm[i].h = (OPJ_UINT32)image_height;
  }

  l_codec = opj_create_compress(OPJ_CODEC_JP2);
  if (!l_codec) {
    return 1;
  }

  l_image = opj_image_create(num_comps,&cmptparm[0],OPJ_CLRSPC_GRAY);
  if (! l_image) {
    opj_destroy_codec(l_codec);
    return 1;
  }
  /*SET IMAGE DATA*/
  l_image->x0 = 0;
  l_image->y0 = 0;
  l_image->x1 = (OPJ_UINT32)image_width;
  l_image->y1 = (OPJ_UINT32)image_height;
  l_image->color_space = OPJ_CLRSPC_GRAY;
  for(uint i = 0; i < input_size; i++){
      l_image->comps[0].data[i] = source[i];
  }

  //scilU_print_buffer((char*)l_image->comps[0].data,input_size*4);

  if (! opj_setup_encoder(l_codec,&l_param,l_image)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to setup the codec!\n");
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  l_stream = opj_stream_create_default_file_stream(output_file, OPJ_FALSE);
  if (! l_stream) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to create the stream from the output file %s !\n",output_file );
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_start_compress(l_codec,l_image,l_stream)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to start compress!\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_encode(l_codec, l_stream)) {
    fprintf(stderr, "ERROR -> test_encoder: failed to encode!\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_end_compress(l_codec,l_stream)) {
    fprintf(stderr, "ERROR -> test_tile_encoder: failed to end compress!\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  opj_stream_destroy(l_stream);
  opj_destroy_codec(l_codec);
  opj_image_destroy(l_image);

  /*READ RESULTS FROM FILE*/

  FILE *fp;

  if ((fp = fopen(output_file, "rb")) == NULL)
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error opening file\n");
    return 1;
  }

  fseek(fp,0,SEEK_END);
  int size = ftell(fp);
  fseek(fp,0,SEEK_SET);
  fread(dest, sizeof(OPJ_BYTE), size, fp);
  fclose(fp);

  if( remove( output_file ) != 0 )
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error deleting file\n");
    return 1;
  }

  *dest_size = size;


  return SCIL_NO_ERR;
}

#pragma GCC diagnostic ignored "-Wunused-parameter"
int scil_opj_decompress_<DATATYPE>(<DATATYPE>* restrict dest, scil_dims* dims, byte* restrict source, const size_t _size)
{
  opj_dparameters_t l_param;
  opj_codec_t * l_codec;
  opj_image_t * l_image;
  opj_stream_t * l_stream;

  int da_x0=0;
  int da_y0=0;
  int da_x1=(OPJ_UINT32)dims->length[0];
  int da_y1=(OPJ_UINT32)dims->length[1];
  char input_file[64];

  //size_t input_size = scil_get_data_size(ctx->datatype, dims);

  size_t input_size = (OPJ_UINT32)dims->length[0]*(OPJ_UINT32)dims->length[1];

  strcpy(input_file,"test.jp2");

  /*WRITE FILE*/

  FILE *fp;

  if ((fp = fopen(input_file, "wb")) == NULL)
  {
    fprintf(stderr, "ERROR -> test_tile_encoder: Error opening file\n");
    return 1;
  }

  fwrite (source, sizeof(OPJ_BYTE), _size, fp);
  fclose (fp);

  /*WRITE FILE*/
  l_stream = opj_stream_create_default_file_stream(input_file,OPJ_TRUE);
  if (!l_stream){
    fprintf(stderr, "ERROR -> failed to create the stream from the file\n");
    return 1;
  }

  /* Set the default decoding parameters */
  opj_set_default_decoder_parameters(&l_param);

  /* */
  l_param.decod_format = OPJ_CODEC_JP2;

  /** you may here add custom decoding parameters */
  /* do not use layer decoding limitations */
  l_param.cp_layer = 0;

  /* do not use resolutions reductions */
  l_param.cp_reduce = 0;

  /* to decode only a part of the image data */
  /*opj_restrict_decoding(&l_param,0,0,1000,1000);*/


  /* JPEG-2000 codestream */

  /* Get a decoder handle */
  l_codec = opj_create_decompress(OPJ_CODEC_JP2);

  /* Setup the decoder decoding parameters using user parameters */
  if (! opj_setup_decoder(l_codec, &l_param))
  {
    fprintf(stderr, "ERROR -> jp2_dump: failed to setup the decoder\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    return 1;
  }

  /* Read the main header of the codestream and if necessary the JP2 boxes*/
  if (! opj_read_header(l_stream, l_codec, &l_image))
  {
    fprintf(stderr, "ERROR -> jp2_to_image: failed to read the header\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (!opj_set_decode_area(l_codec, l_image, da_x0, da_y0, da_x1, da_y1))
  {
    fprintf(stderr,	"ERROR -> jp2_to_image: failed to set the decoded area\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_decode(l_codec,l_stream,l_image))
  {
    fprintf(stderr,	"ERROR -> decode: failed\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  if (! opj_end_decompress(l_codec,l_stream))
  {
    fprintf(stderr,	"ERROR -> decompress: failed\n");
    opj_stream_destroy(l_stream);
    opj_destroy_codec(l_codec);
    opj_image_destroy(l_image);
    return 1;
  }

  //scilU_print_buffer((char*)l_image->comps[0].data,l_image->x1 * l_image->y1 * 4);

  // INT32 TO DATATYPE
  for (uint i = 0; i < l_image->x1 * l_image->y1; i++)
    dest[i] = (<DATATYPE>)l_image->comps[0].data[i];

  /* Free memory */
  opj_stream_destroy(l_stream);
  opj_destroy_codec(l_codec);
  opj_image_destroy(l_image);
  return 0;
}

// End repeat

scil_compression_algorithm algo_opj = {
    .c.DNtype = {
	      CREATE_INITIALIZER(scil_opj)
    },
    "opj",
    9,//compressor_id
    SCIL_COMPRESSOR_TYPE_DATATYPES,
    0 //is_lossy
};
