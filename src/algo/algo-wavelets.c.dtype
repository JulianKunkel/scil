// This file is part of SCIL.
//
// SCIL is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SCIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with SCIL.  If not, see <http://www.gnu.org/licenses/>.

#include <assert.h>
#include <algo/algo-wavelets.h>

#include "macros.h"
#include "alloc.h"
#include "wav_filters.h"
#include "wav_trf.h"
#include "wav_gen.h"
#include <string.h>

// Repeat for each data type

#pragma GCC diagnostic ignored "-Wunused-parameter"
int scil_wavelets_compress_<DATATYPE>(const scil_context_p ctx,
                        byte * restrict dest,
                        size_t* restrict dest_size,
                        <DATATYPE>*restrict source,
                        const scil_dims* dims)
{
    int i,j;
    int Ni = dims->length[1], Nj = dims->length[0];
  	float **buffer_t;
  	int shift_arr_r[MAX_ARR_SIZE],shift_arr_c[MAX_ARR_SIZE];

  	// 4 levels of wavelets.
  	const int levs=4;
  	int Nl,Nh;
  	float *lp,*hp;

    // Choose wavelet filter. List of filters is in wav_trf.c
  	choose_filter('H',9);

  	// Main buffer for operations.
  	buffer_t=allocate_2d_float(Ni,Nj,0);

	  for(i=levs-1;i>=0;i--) {
  		shift_arr_r[i]=shift_arr_c[i]=0;
  	}

  	for(i=0;i<Ni;i++) {
      memcpy(buffer_t[i], source+i*Nj, Nj*sizeof(float));
  	}

  	// Select the forward bank of filters.
  	lp=MFLP;Nl=Nflp;
  	hp=MFHP;Nh=Nfhp;

  	wav2d_inpl(buffer_t,Ni,Nj,levs,lp,Nl,hp,Nh,1,shift_arr_r,shift_arr_c);

    for(i=0;i<Ni;i++) {
      memcpy(dest+i*Nj*sizeof(float), buffer_t[i], Nj*sizeof(float));
    }

  	// Free buffers.
  	free_2d_float(buffer_t,Ni);

    /*int i,j;
    int Ni = dims->length[1], Nj = dims->length[0];
  	float **buffer_t;
  	float **ctrf[4],**cim;
  	float mse=0;
  	const int levs=1;

  	buffer_t=allocate_2d_float(Ni,Nj,0);

  	for(i=0;i<4;i++)
  		ctrf[i]=allocate_2d_float(Ni,Nj,0);

  	// Copy "source" input to the buffer.
    for(i=0;i<Ni;i++) {

  		for(j=0;j<Nj;j++) {

  			buffer_t[i][j]=(*(float*)(source+i*Nj+j));
  		}
  	}

    printf("\nInput:");
    for(i=0;i<Ni;i++) {
  		for(j=0;j<Nj;j++) {
  			printf(" %f", buffer_t[i][j]);
  		}
  	}

  		// Forward transform.
  		// Allocates components of ctrf.
  		complex_wav_forw(buffer_t,ctrf,Ni,Nj,levs);

      printf("\n\nFWT:");
      for(int l =0; l<4;l++){
        for(i=0;i<Ni;i++) {
    		    for(j=0;j<Nj;j++) {
    			       printf(" %f", ctrf[l][i][j]);
            }
        }
        printf("\n>");
      }

  		// Inverse transform.
  		// Allocates the temporary result array cim.
  		cim=complex_wav_inv(ctrf,Ni,Nj,levs);

      printf("\n\nINV:");
      for(int l =0; l<4;l++){
        for(i=0;i<Ni;i++) {
    		    for(j=0;j<Nj;j++) {
    			       printf(" %f", ctrf[l][i][j]);
            }
        }
        printf("\n>");
      }

      printf("\n\nResult:");
      for(i=0;i<Ni;i++) {
    		for(j=0;j<Nj;j++) {
    			printf(" %f", cim[i][j]);
    		}
    	}

  	mse=0;
  	for(i=0;i<Ni;i++)
  		for(j=0;j<Nj;j++) {

  			mse+=((*(source+i*Nj+j))-cim[i][j])*((*(source+i*Nj+j))-cim[i][j]);
  		}
  	mse/=Ni*Nj;

  	printf("\nThe mse due to transformation and inverse transformation is: \n");
  	printf("\t%8.4f, ( %8.4f dB)\n ",mse,10*log10(255*255/mse));
  	printf("(Very small amount of mse is OK due to numerical errors.)\n");

  	// Free ctrf components allocated.
  	for(i=0;i<4;i++)
  		free_2d_float(ctrf[i],Ni);

  	// Free buffer.
  	free_2d_float(buffer_t,Ni);

  	// Free temporary storage for results.
  	free_2d_float(cim,Ni);
*/

    return 0;
}

#pragma GCC diagnostic ignored "-Wunused-parameter"
int  scil_wavelets_decompress_<DATATYPE>( <DATATYPE>*restrict data_out,
                            scil_dims* dims,
                            byte*restrict compressed_buf_in,
                            const size_t in_size)
{
  int i,j;
  int Ni = dims->length[1], Nj = dims->length[0];
  float **buffer_t;
  int shift_arr_r[MAX_ARR_SIZE],shift_arr_c[MAX_ARR_SIZE];

  // 4 levels of wavelets.
  const int levs=4;
  int Nl,Nh;
  float *lp,*hp;

  buffer_t=allocate_2d_float(Ni,Nj,0);

  for(i=0;i<Ni;i++) {
    memcpy(buffer_t[i], compressed_buf_in+i*Nj*sizeof(float), Nj*sizeof(float));
  }

  // Choose wavelet filter. List of filters is in wav_trf.c
  choose_filter('H',9);

  for(i=levs-1;i>=0;i--) {
    shift_arr_r[i]=shift_arr_c[i]=0;
  }

  // Select the inverse bank of filters.
  lp=MILP;Nl=Nilp;
  hp=MIHP;Nh=Nihp;

  // Inverse transform.
  wav2d_inpl(buffer_t,Ni,Nj,levs,lp,Nl,hp,Nh,0,shift_arr_r,shift_arr_c);

  for(i=0;i<Ni;i++) {
    memcpy(data_out+i*Nj, buffer_t[i], Nj*sizeof(float));
  }

  // Free buffers.
  free_2d_float(buffer_t,Ni);

  return 0;
}
// End repeat

scil_compression_algorithm algo_wavelets = {
    .c.DNtype = {
        CREATE_INITIALIZER(scil_wavelets)
    },
    "wavelets",
    11,
    SCIL_COMPRESSOR_TYPE_DATATYPES
};
