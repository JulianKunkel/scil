#include <scil.h>

#include <algo/algo-quantize.h>

#include <scil-internal.h>

#include <stdio.h>
#include <assert.h>
#include <math.h>

// Repeat for each data type

static uint64_t scil_quantize_value_<DATATYPE>(<DATATYPE> value,
                                               double absolute_tolerance,
                                               <DATATYPE> minimum)
{
    return (uint64_t)round( (double)(value - minimum) / (2.0 * absolute_tolerance) );
}

static <DATATYPE> scil_unquantize_value_<DATATYPE>(uint64_t value,
                                                   double absolute_tolerance,
                                                   <DATATYPE> minimum)
{
    return minimum + (<DATATYPE>)(value * 2.0 * absolute_tolerance);
}

static <DATATYPE> scil_find_minimum_<DATATYPE>(const <DATATYPE>* const buffer,
                                               size_t count)
{
    assert(buffer != NULL);

    <DATATYPE> min = INFINITY;

    for(size_t i = 0; i < count; ++i)
    {
        if(buffer[i] < min) { min = buffer[i]; }
    }

    return min;
}

static <DATATYPE> scil_find_maximum_<DATATYPE>(const <DATATYPE>* const buffer,
                                               size_t count)
{
    assert(buffer != NULL);

    <DATATYPE> max = -INFINITY;

    for(size_t i = 0; i < count; ++i)
    {
        if(buffer[i] > max) { max = buffer[i]; }
    }

    return max;
}

static void scil_find_minimum_maximum_<DATATYPE>(const <DATATYPE>* const restrict buffer,
                                                 size_t count,
                                                 <DATATYPE>* const minimum,
                                                 <DATATYPE>* const maximum)
{
    assert(buffer != NULL);
    assert(minimum != NULL);
    assert(maximum != NULL);

    <DATATYPE> min = INFINITY;
    <DATATYPE> max = -INFINITY;

    for(size_t i = 0; i < count; ++i){
        if (buffer[i] < min) { min = buffer[i]; }
        if (buffer[i] > max) { max = buffer[i]; }
    }

    *minimum = min;
    *maximum = max;
}

static uint64_t scil_calculate_bits_needed_<DATATYPE>(<DATATYPE> minimum,
                                                      <DATATYPE> maximum,
                                                      double absolute_tolerance)
{
    return (uint64_t)ceil( log2( 1.0 + (double)(maximum - minimum) / (2.0 * absolute_tolerance) ) );
}

static int scil_quantize_buffer_<DATATYPE>(uint64_t* const restrict dest,
                                                  const <DATATYPE>* const restrict source,
                                                  size_t count,
                                                  double absolute_tolerance,
                                                  <DATATYPE> minimum,
                                                  <DATATYPE> maximum,
                                                  uint8_t bits_per_value)
{
    assert(dest != NULL);
    assert(source != NULL);



    for(size_t i = 0; i < count; ++i){
        dest[i] = scil_quantize_value_<DATATYPE>(source[i], absolute_tolerance, minimum);
    }

    return 0;
}

static int scil_unquantize_buffer_<DATATYPE>(<DATATYPE>* const restrict dest,
                                             const uint64_t* const restrict source,
                                             size_t count,
                                             double absolute_tolerance,
                                             <DATATYPE> minimum)
{
    assert(dest != NULL);
    assert(source != NULL);

    for(size_t i = 0; i < count; ++i){
        dest[i] = scil_unquantize_value_<DATATYPE>(source[i], absolute_tolerance, minimum);
    }

    return 0;
}

int scil_quantize_compress_<DATATYPE>(const scil_context_t* ctx,
                                      int64_t* restrict dest,
                                      size_t* restrict out_size,
                                      <DATATYPE>*restrict source,
                                      const scil_dims* dims)
{
    size_t count = scil_get_data_count(dims);

    <DATATYPE> minimum, maximum;
    scil_find_minimum_maximum_<DATATYPE>(source, count, &minimum, &maximum);

    uint8_t bits_per_value = scil_calculate_bits_needed_<DATATYPE>(minimum, maximum, ctx->hints.absolute_tolerance);
    if (bits_per_value > 64)
        return 1; // Quantizing would result in values bigger than UINT64_MAX

    *(double*)dest = (double)minimum;
    ++dest;

    *(double*)dest = ctx->hints.absolute_tolerance;
    ++dest;

    *out_size = 16;
    *out_size += count * sizeof(int64_t);

    char value[2];
    snprintf(value, 2, "%u", bits_per_value);
    scilI_dict_put(ctx->pipeline_params, "bits_per_value", value);

    return scil_quantize_buffer_<DATATYPE>((uint64_t*)dest, source, count, ctx->hints.absolute_tolerance, minimum, maximum, bits_per_value);
}

int scil_quantize_decompress_<DATATYPE>(<DATATYPE>*restrict dest,
                                        scil_dims* dims,
                                        int64_t*restrict source,
                                        const size_t in_size)
{
    double minimum = *(double*)source;
    ++source;

    double abstol  = *(double*)source;
    ++source;

    return scil_unquantize_buffer_<DATATYPE>(dest, (uint64_t*)source, scil_get_data_count(dims), abstol, minimum);
}
// End repeat

scilI_algorithm_t algo_quantize = {
    .c.Ctype = {
        CREATE_INITIALIZER(scil_quantize)
    },
    "quantize",
    9,
    SCIL_COMPRESSOR_TYPE_DATATYPES_CONVERTER,
    1
};
